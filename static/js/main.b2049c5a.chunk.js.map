{"version":3,"sources":["VGdmAppointment.ts","index.tsx"],"names":["say","text","send","_context","type","value","listen","store_input","input","grammar","person_to_meet","undefined","time_to_meet","day_to_meet","words","split","i","length","concat","person","day","time","cancel","boolgrammar","yes","no","dmMenu","initial","states","init","on","CLICK","welcome","RECOGNISED","target","prompt","entry","ENDSPEECH","ask","invoke_rasa","invoke","id","src","context","event","nluRequest","recResult","onDone","actions","assign","intentResult","data","intent","name","onError","console","log","answer","RASA_DONE","cond","who","appointmentData","DATA_STORED","nomatch","sendnext","DIRECT","missing_person","missing_day","time_only","day_only","allday","confirm","confirmallday","confirmtime","meetingbooked","todo","timer","fetch","Request","proxyurl","method","body","then","json","inspect","url","iframe","machine","Machine","dm","asrtts","idle","LISTEN","SPEAK","ttsAgenda","recognising","exit","ASRRESULT","counter","MAXSPEECH","count","progress","match","speaking","recLogResult","test","logIntent","nluData","ReactiveButton","props","state","matches","className","style","animation","App","useSpeechSynthesis","onEnd","speak","useSpeechRecognition","onResult","result","stop","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","recStop","changeColour","document","background","ttsStart","effect","ttsCancel","current","onClick","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.b2049c5a.chunk.js","sourcesContent":["import { MachineConfig, send, Action, assign, actions } from \"xstate\";\nimport { invoke } from \"xstate/lib/actionTypes\";\nimport { mapContext } from \"xstate/lib/utils\";\n// import { dmMachine } from \"./dmAppointment-old\";\n\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction listen(): Action<SDSContext, SDSEvent> {\n    return send('LISTEN')\n}\n\nfunction store_input(input: string, grammar: Object) {\n    var person_to_meet = undefined\n    var time_to_meet = undefined\n    var day_to_meet = undefined\n\n    var words = input.split(\" \");\n    for (var i = 0; i < words.length; i += 1) {\n        if ( \"person\" in (grammar[words[i]] || {})){\n            person_to_meet = words[i];\n        } else if (\"day\" in (grammar[words[i]] || {})){\n            day_to_meet = words[i];\n        } else if (words[i] === \"at\") {\n            var time_phrase = words[i].concat(' ', words[i + 1]);\n            if (\"time\" in (grammar[time_phrase] || {})){\n                time_to_meet = words[i + 1];\n            }\n        }  else {\n\n        }\n    }\n    return {\"person_to_meet\": person_to_meet, \"day_to_meet\": day_to_meet, \"time_to_meet\": time_to_meet};\n}\n\nconst grammar: { [index: string]: { person?: string, day?: string, time?: string, cancel?: string,} } = {\n    \"John\": { person: \"John Appleseed\" },\n    \"Jack\": {person: \"Jack Jackson\"},\n    \"Anna\": {person: \"Anna\"},\n    \"on Monday\": { day: \"Monday\" },\n    \"Monday\": { day: \"Monday\" },\n    \"on Tuesday\": { day: \"Tuesday\" },\n    \"Tuesday\": { day: \"Tuesday\" },\n    \"on Wednesday\": { day: \"Wednesday\" },\n    \"Wednesday\": { day: \"Wednesday\" },\n    \"on Thursday\": { day: \"Thursday\" },\n    \"Thursday\": { day: \"Thursday\" },\n    \"on Friday\": { day: \"Friday\" },\n    \"Friday\": { day: \"Friday\" },\n    \"on Saturday\": { day: \"Saturday\" },\n    \"Saturday\": { day: \"Saturday\" },\n    \"on Sunday\": { day: \"Sunday\" },\n    \"Sunday\": { day: \"Sunday\" },\n    \"at 1 a.m.\": { time: \"1:00\" },\n    \"at 2 a.m.\": { time: \"2:00\" },\n    \"at 3 a.m.\": { time: \"3:00\" },\n    \"at 4 a.m.\": { time: \"4:00\" },\n    \"at 5 a.m.\": { time: \"5:00\" },\n    \"at 6 a.m.\": { time: \"6:00\" },\n    \"at 7 a.m.\": { time: \"7:00\" },\n    \"at 8\": { time: \"8:00\" },\n    \"at 9\": { time: \"9:00\" },\n    \"at 10\": { time: \"10:00\" },\n    \"at 11\": { time: \"11:00\" },\n    \"at 12\": { time: \"12:00\" },\n    \"at 1\": { time: \"13:00\" },\n    \"at 2\": { time: \"14:00\" },\n    \"at 3\": { time: \"15:00\" },\n    \"at 4\": { time: \"16:00\" },\n    \"at 5\": { time: \"17:00\" },\n    \"at 6\": { time: \"18:00\" },\n    \"at 7\": { time: \"19:00\" },\n    \"at 8 p.m.\": { time: \"20:00\" },\n    \"at 9 p.m.\": { time: \"21:00\" },\n    \"at 10 p.m.\": { time: \"22:00\" },\n    \"at 11 p.m.\": { time: \"23:00\" },\n    \"at midnight\": {time: \"00:00\"},\n    \"quit\": {cancel: \"cancel\"},\n    \"cancel\": {cancel: \"cancel\"},\n    \"nevermind\": {cancel: \"cancel\"}\n}\n\nconst boolgrammar: {[index: string]: {yes?: boolean, no?:boolean}} = {\n    \"yes\": {yes: true },\n    \"yep\": {yes: true },\n    \"of course\": {yes: true },\n    \"sure\": {yes: true },\n    \"no\": {no: false },\n    \"no way\": {no: false },\n    \"nope\": {no: false },\n}\n\nexport const dmMenu: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'welcome'\n            }\n        },\n        welcome: {\n            initial: \"prompt\",\n            on: { \n                RECOGNISED: { \n                    target: 'invoke_rasa',\n                }\n            },\n            states: {\n                prompt: { \n                    entry: say(\"What do you want to do?\"),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n            }\n        },\n        invoke_rasa: {\n            invoke: {\n                id: 'rasa',\n                src: (context, event) => nluRequest(context.recResult),\n                onDone: {\n                    target: 'answer',\n                    actions: [\n                        assign((context, event) => { return { intentResult: event.data.intent.name } }),\n                        // (context:SDSContext, event:any) => console.log('<< Intent: ' + context.intentResult),\n                        send('RASA_DONE')\n                    ],\n                },\n                onError: {\n                    target: 'welcome',\n                    actions: (context,event) => console.log(event.data),\n                },\n            }\n        },\n        answer: {\n            on: { \n                RASA_DONE: [{\n                    cond: (context: { intentResult: string; }) => \"add_todo_item\" == context.intentResult,\n                    actions: (context:SDSContext) => console.log('<< TODO: ' + context.intentResult),\n                    target: 'todo',\n                },\n                {\n                    cond: (context: { intentResult: string; }) => \"make_appointment\" == context.intentResult,\n                    actions: (context:SDSContext) => console.log('<< APP: ' + context.intentResult),\n                    target: 'who',\n                },\n                {\n                    cond: (context: { intentResult: string; }) => \"set_timer\" == context.intentResult,\n                    actions: (context:SDSContext) => console.log('<< TIMER: ' + context.intentResult),\n                    target: 'timer',\n                }]\n            },\n        },\n        who: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [\n                {   \n                    actions: [\n                        assign((context) => {\n                            console.log(context.recResult)\n                            console.log(store_input(context.recResult, grammar))\n                            return {\n                                appointmentData: store_input(context.recResult, grammar),\n                            }\n                            \n                        }),\n                        send('DATA_STORED'),\n                    ]\n                },\n            ],\n                DATA_STORED: [\n                    {actions: [\n                        assign((context) => {\n                            console.log(store_input(context.recResult, grammar).person_to_meet)\n                            return {\n                                person: store_input(context.recResult, grammar).person_to_meet,\n                            }\n                        }),\n                        assign((context) => {\n                            console.log(store_input(context.recResult, grammar).day_to_meet)\n                            return {\n                                day: store_input(context.recResult, grammar).day_to_meet,\n                            }\n                        }),\n                        assign((context) => {\n                            console.log(store_input(context.recResult, grammar).time_to_meet)\n                            return {\n                                time: store_input(context.recResult, grammar).time_to_meet,\n                            }\n                        })\n                    ],\n                    target: 'sendnext'\n                }\n            ]\n            },\n            states: {\n                prompt: {\n                    entry: say(\"Okay, what are the details of the meeting you want to set up?\"),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry I don't know them\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                }\n            }\n        },\n        sendnext:{\n            entry: send('DIRECT'),\n            on: {\n                DIRECT: [\n                {cond: (context)  => context.person != undefined  && context.day != undefined && context.time != undefined,\n                target: 'confirmtime'},\n                {\n                 cond: (context) => context.person != undefined && context.day != undefined,\n                 target: 'allday',\n                },\n                {\n                 cond: (context)  => context.day != undefined && context.time != undefined,\n                 target: 'missing_person'   \n                },\n                {\n                 cond: (context)  => context.person != undefined && context.time != undefined,\n                 target: 'missing_day'   \n                },\n                {\n                 cond: (context) => context.person != undefined,\n                 target: 'day',\n                },\n                {\n                 cond: (context) => context.day != undefined,\n                 target: 'day_only'\n                },\n                {\n                 cond: (context) => context.time != undefined,\n                 target: 'time_only'\n                }\n                ]\n            }\n        },\n        missing_person: {\n            initial: \"prompt\",\n            on: { \n                RECOGNISED: [{\n                    cond: (context) => \"person\" in (grammar[context.recResult] || {}),\n                    actions: assign((context) => { return { person: grammar[context.recResult].person } }),\n                    target: \"confirmtime\"\n\n                },\n                {\n                    cond: (context) => \"cancel\" in (grammar[context.recResult] || {}),\n                    actions: assign((context) => { return { cancel: grammar[context.recResult].cancel } }),\n                    target: \"init\"\n                },\n                { target: \".nomatch\" }]\n            },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `OK. ${context.day} at ${context.time}. With who are you meeting?`\n                    })),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry I didn't catch that\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                },\n            }\n        },\n        missing_day: {\n            initial: \"prompt\",\n            on: { \n                RECOGNISED: [{\n                    cond: (context) => \"day\" in (grammar[context.recResult] || {}),\n                    actions: assign((context) => { return { day: grammar[context.recResult].day } }),\n                    target: \"confirmtime\"\n\n                },\n                {\n                    cond: (context) => \"cancel\" in (grammar[context.recResult] || {}),\n                    actions: assign((context) => { return { cancel: grammar[context.recResult].cancel } }),\n                    target: \"init\"\n                },\n                { target: \".nomatch\" }]\n            },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `OK. With ${context.person} at ${context.time}. On which day is your meeting?`\n                    })),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry I didn't catch that\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                },\n            }\n        },\n        day: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [\n                {   \n                    actions: [\n                        assign((context) => {\n                            console.log(context.recResult)\n                            console.log(store_input(context.recResult, grammar))\n                            return {\n                                appointmentData: store_input(context.recResult, grammar),\n                            }\n                            \n                        }),\n                        send('DATA_STORED'),\n                    ]\n                },\n            ],\n                DATA_STORED: [\n                    {actions: [\n                        assign((context) => {\n                            console.log(store_input(context.recResult, grammar).day_to_meet)\n                            return {\n                                day: store_input(context.recResult, grammar).day_to_meet,\n                            }\n                        }),\n                        assign((context) => {\n                            console.log(store_input(context.recResult, grammar).time_to_meet)\n                            return {\n                                time: store_input(context.recResult, grammar).time_to_meet,\n                            }\n                        })\n                    ],\n                    target: 'sendnext'\n                }\n            ]\n            },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `Okay, lets create an appointment with ${context.person}. When is the meeting?`\n                    })),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry I did't catch that\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                }\n            }\n        },\n        time_only: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [\n                {   \n                    actions: [\n                        assign((context) => {\n                            console.log(context.recResult)\n                            console.log(store_input(context.recResult, grammar))\n                            return {\n                                appointmentData: store_input(context.recResult, grammar),\n                            }\n                            \n                        }),\n                        send('DATA_STORED'),\n                    ]\n                },\n            ],\n                DATA_STORED: [\n                    {actions: [\n                        assign((context) => {\n                            console.log(store_input(context.recResult, grammar).person_to_meet)\n                            return {\n                                person: store_input(context.recResult, grammar).person_to_meet,\n                            }\n                        }),\n                        assign((context) => {\n                            console.log(store_input(context.recResult, grammar).day_to_meet)\n                            return {\n                                day: store_input(context.recResult, grammar).day_to_meet,\n                            }\n                        })\n                    ],\n                    target: 'sendnext'\n                }\n            ]\n            },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `Okay, lets create an appointment at ${context.time}. Who are you meeting with? And on which day?`\n                    })),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry I did't catch that\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                }\n            }\n        },\n        day_only: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [\n                {   \n                    actions: [\n                        assign((context) => {\n                            console.log(context.recResult)\n                            console.log(store_input(context.recResult, grammar))\n                            return {\n                                appointmentData: store_input(context.recResult, grammar),\n                            }\n                            \n                        }),\n                        send('DATA_STORED'),\n                    ]\n                },\n            ],\n                DATA_STORED: [\n                    {actions: [\n                        assign((context) => {\n                            console.log(store_input(context.recResult, grammar).person_to_meet)\n                            return {\n                                person: store_input(context.recResult, grammar).person_to_meet,\n                            }\n                        }),\n                        assign((context) => {\n                            console.log(store_input(context.recResult, grammar).time_to_meet)\n                            return {\n                                time: store_input(context.recResult, grammar).time_to_meet,\n                            }\n                        })\n                    ],\n                    target: 'sendnext'\n                }\n            ]\n            },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `Okay, lets create an appointment on ${context.day}. Who are you meeting with? And at what time?`\n                    })),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry I did't catch that\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                }\n            }\n        },\n        allday: {\n            initial: \"prompt\",\n            on: { \n                RECOGNISED: [{\n                    cond: (context) => \"yes\" in (boolgrammar[context.recResult] || {}),\n                    actions: assign((context) => { return { confirm: boolgrammar[context.recResult].yes } }),\n                    target: \"confirmallday\",\n\n                },\n                {\n                    cond: (context) => \"no\" in (boolgrammar[context.recResult] || {}),\n                    actions: assign((context) => { return { confirm: boolgrammar[context.recResult].no } }),\n                    target: \"time\",\n                },\n                {\n                    cond: (context) => \"cancel\" in (grammar[context.recResult] || {}),\n                    actions: assign((context) => { return { cancel: grammar[context.recResult].cancel } }),\n                    target: \"init\"\n                },\n                { target: \".nomatch\" }]\n            },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `OK. ${context.day}. Is your meeting all day?`\n                    })),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry I didn't catch that\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                },\n            }\n        },\n\n        confirmallday: {\n            initial: \"prompt\",\n            on: { \n                RECOGNISED: [{\n                    cond: (context) => \"yes\" in (boolgrammar[context.recResult] || {}),\n                    actions: assign((context) => { return { confirm: boolgrammar[context.recResult].yes } }),\n                    target: \"meetingbooked\",\n\n                },\n                {\n                    cond: (context) => \"no\" in (boolgrammar[context.recResult] || {}),\n                    actions: assign((context) => { return { confirm: boolgrammar[context.recResult].no } }),\n                    target: \"who\",\n                },\n                {\n                    cond: (context) => \"cancel\" in (grammar[context.recResult] || {}),\n                    actions: assign((context) => { return { cancel: grammar[context.recResult].cancel } }),\n                    target: \"init\"\n                },\n                { target: \".nomatch\" }]\n            },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `Do you want me to create an appointment with ${context.person} on ${context.day} for the whole day?`\n                    })),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry I didn't catch that\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                },\n            }\n        },\n        time: {\n            initial: \"prompt\",\n            on: { \n                RECOGNISED: [{\n                    cond: (context) => \"time\" in (grammar[context.recResult] || {}),\n                    actions: assign((context) => { return { time: grammar[context.recResult].time } }),\n                    target: \"confirmtime\"\n\n                },\n                {\n                    cond: (context) => \"cancel\" in (grammar[context.recResult] || {}),\n                    actions: assign((context) => { return { cancel: grammar[context.recResult].cancel } }),\n                    target: \"init\"\n                },\n                { target: \".nomatch\" }]\n            },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `OK. At what time is your meeting?`\n                    })),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry I didn't catch that\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                },\n            }\n        },\n        confirmtime: {\n            initial: \"prompt\",\n            on: { \n                RECOGNISED: [{\n                    cond: (context) => \"yes\" in (boolgrammar[context.recResult] || {}),\n                    actions: assign((context) => { return { confirm: boolgrammar[context.recResult].yes } }),\n                    target: \"meetingbooked\",\n\n                },\n                {\n                    cond: (context) => \"no\" in (boolgrammar[context.recResult] || {}),\n                    actions: assign((context) => { return { confirm: boolgrammar[context.recResult].no } }),\n                    target: \"who\",\n                },\n                {\n                    cond: (context) => \"cancel\" in (grammar[context.recResult] || {}),\n                    actions: assign((context) => { return { cancel: grammar[context.recResult].cancel } }),\n                    target: \"init\"\n                },\n                { target: \".nomatch\" }]\n            },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `Do you want me to create an appointment with ${context.person} on ${context.day} at ${context.time}?`\n                    })),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry I didn't catch that\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                },\n            }\n        },\n        meetingbooked: {\n            initial: \"prompt\",\n            on: { \n                ENDSPEECH: \"init\" ,\n            },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `Your appointment has been created!`\n                    })),\n                },\n            }\n        },\n        todo: {\n            initial: 'prompt',\n            states: {\n                prompt: { entry: say(\"Okay, let's create a new to do item.\")}\n            },\n            on: { ENDSPEECH: \"init\" }\n        },\n        timer: {\n            initial: 'prompt',\n            states: {\n                prompt: { entry: say(\"Okay, let's set a timer.\")}\n            },\n            on: { ENDSPEECH: \"init\" }\n        },\n    }\n})\n\n/* RASA API\n *  */\nconst proxyurl = \"https://cors-anywhere.herokuapp.com/\";\nconst rasaurl = 'https://rasa-nlu-heroku.herokuapp.com/model/parse'\nconst nluRequest = (text: string) =>\n    fetch(new Request(proxyurl + rasaurl, {\n        method: 'POST',\n        // headers: { 'Origin': 'http://maraev.me' }, // only required with proxy\n        body: `{\"text\": \"${text}\"}`\n    }))\n        .then(data => data.json());\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, State } from \"xstate\";\nimport { MachineConfig, Action, actions} from \"xstate\";\nconst {send, cancel} = actions\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\n// import { dmMachine } from \"./dmAppointment-old\";\nimport { dmMenu } from \"./VGdmAppointment\";\n\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\nimport { useSpeechSynthesis, useSpeechRecognition } from 'react-speech-kit';\n\n\n// function say(text: string): Action<SDSContext, SDSEvent> {\n//     return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n// }\n\nlet count = 0\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    states: {\n        dm: {\n            ...dmMenu\n        },\n        asrtts: {\n            initial: 'idle',\n            states: {\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    }\n                },\n                recognising: {\n                    initial: 'progress',\n                    entry: 'recStart',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => { return { recResult: event.value } })],\n                            target: '.match'\n                        },\n                        RECOGNISED: {\n                            target: 'idle',\n                            actions: [\n                                assign((context)=>{\n                                    return {counter: context.counter = 0}\n                                } ),\n                                cancel('maxsp'),\n                            ]\n                            },\n                        MAXSPEECH: {\n                            target: 'idle',\n                            actions: assign((context)=>{\n                                if (context.counter) {\n                                    return {counter: context.counter + 1}\n                                } else {\n                                    return {counter: count + 1}\n                                }\n                            \n                            })\n                    },\n                    },\n                    states: {\n                        progress: {\n                        },\t    \t\t\t\t\t\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                    }\n                },\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                    }\n                }\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('<< ASR: ' + context.recResult);\n            },\n            test: () => {\n                console.log('test')\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    switch (true) {\n        case props.state.matches({ asrtts: 'recognising' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"glowing 20s linear\" }} {...props}>\n                    Listening...\n                </button>\n            );\n        case props.state.matches({ asrtts: 'speaking' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"bordering 1s infinite\" }} {...props}>\n                    Speaking...\n                </button>\n            );\n        default:\n            return (\n                <button type=\"button\" className=\"glow-on-hover\" {...props}>\n                    Click to start\n                </button >\n            );\n    }\n}\n\nfunction App() {\n    const { speak, cancel, speaking } = useSpeechSynthesis({\n        onEnd: () => {\n            send('ENDSPEECH');\n        },\n    });\n    const { listen, listening, stop } = useSpeechRecognition({\n        onResult: (result: any) => {\n            send({ type: \"ASRRESULT\", value: result });\n        },\n    });\n    const [current, send, service] = useMachine(machine, {\n        devTools: true,\n        actions: {\n            recStart: asEffect(() => {\n                console.log('Ready to receive a color command.');\n                listen({\n                    interimResults: false,\n                    continuous: true\n                });\n            }),\n            recStop: asEffect(() => {\n                console.log('Recognition stopped.');\n                stop()\n            }),\n            changeColour: asEffect((context) => {\n                console.log('Repainting...');\n                document.body.style.background = context.recResult;\n            }),\n            ttsStart: asEffect((context, effect) => {\n                console.log('Speaking...');\n                speak({ text: context.ttsAgenda })\n            }),\n            ttsCancel: asEffect((context, effect) => {\n                console.log('TTS STOP...');\n                cancel()\n            })\n            /* speak: asEffect((context) => {\n\t     * console.log('Speaking...');\n             *     speak({text: context.ttsAgenda })\n             * } */\n        }\n    });\n\n\n    return (\n        <div className=\"App\">\n            <ReactiveButton state={current} onClick={() => send('CLICK')} />\n        </div>\n    )\n};\n\n\n\n/* RASA API\n *  */\nconst proxyurl = \"https://cors-anywhere.herokuapp.com/\";\nconst rasaurl = 'https://rasa-nlu-heroku.herokuapp.com/model/parse'\nconst nluRequest = (text: string) =>\n    fetch(new Request(proxyurl + rasaurl, {\n        method: 'POST',\n        headers: { 'Origin': 'http://localhost:3000/react-xstate-colourchanger' }, // only required with proxy\n        body: `{\"text\": \"${text}\"}`\n    }))\n        .then(data => data.json());\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);"],"sourceRoot":""}